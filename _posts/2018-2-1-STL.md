---
layout: post
title:  "[C++] STL"
subtitle:   "STL"
categories: Programming
tags: C++
comments: true
---

### 표준 C++ 라이브러리

---


![stl](https://hanareum95.github.io/assets/img/c++/STL_1.PNG)


#### STL(Standard Template Library)

STL은 템플릿을 사용하여 만들어진 라이브러리이다. 

<br/>

#### STL 컨테이너

컨테이너란 객체를 저장하는 객체, 자료구조라고도 한다. 클래스 템플릿으로 구현되어있다.

컨테이너는 크게 sequence container, associative container로 나뉜다.

-  sequence container : array, vector, list, deque
-  associative container : set, multiset, map, multimap

<br/>

#### STL 컨테이너 Adaptor

구성요소의 인터페이스를 변경해 새로운 인터페이스를 갖는 구성요소로 변경

- stack, queue, priority_queue

<br/>

#### STL 알고리즘

STL에서 제공하는 함수들을 의미한다.

ex) 정렬, 검색

<br/>

#### STL 장단점

| 장점                                       | 단점                                       |
| ---------------------------------------- | ---------------------------------------- |
| - 소스 크기의 축소<br/>- 일반화를 지원한다. ( 하나의 알고리즘으로 복수 개의 컨테이너에 동일한 작업을 수행 )<br/>- 컴파일 타임 매커니즘을 사용하기 때문에 실행시의 효율 저하가 거의 없다.<br/>- 객체 지향적이지 않다. ( 객체를 사용하긴 하지만 STL자체가 객체를 반드시 요구하는것은 아니다. )<br/>- 표준이므로 이식성이 확보된다. ( 어떠한 컴파일러로도 컴파일 가능 )<br/>- 확장 가능하다. | - 디버깅이 어려다.<br/>- iterator와 컨테이너가 분리되어서 존재한다. 이는 thread프로그래밍시 문제를 발생할 소지를 갖고있다.<br/>- 템플릿 기반이므로 타입마다 함수와 클래스가 매번 구체화되어 코드가 비대해질 수 있다.<br/>- 템플릿을 사용하므로 C++ 예외코드(try-catch문)을 같이 사용하기 힘들다. |

<br/>

<br/>

### 1. 적은 양의 자료일 경우

---

<br/>

#### < Array >

| 장점             | 단점         |
| -------------- | ---------- |
| - 적은 양의 자료에 유리 | - 크기 변경 불가 |

<br/>

#### < Vector >

- 배열과 같이 연속적이므로 iterator뿐만 아니라 position index로도 접근(랜덤 액세스) 가능
- 동적으로 확장/축소가 가능한 dynamic array
- 원소는 할당 가능하고 복사 가능하다면 어떠한 타입도 가능
- 반복자는 랜덤 액세스 반복자이므로 사용자는 STL의 모든 알고리즘을 사용할 수 있다.
- 끝에 원소를 추가하거나 제거할경우 성능이 좋지만, 반대로 중간 삽입은 모든 원소를 이동하는 문제로 성능이 좋지 않다.
- 동적으로 컨테이너 크기가 변할 수 있지만, 확장시 reallocation 비용이 크다. 따라서 reserve와 같은 함수로 재할당을 피하는 것이 좋다.
- 원소값을 고다로 제거하는 멤버 함수를 가지고 있지 않으므로 STL알고리즘을 사용해야한다.

| 장점                                       | 단점                                       |
| ---------------------------------------- | ---------------------------------------- |
| - 적은 양의 자료에 유리<br/>- 크기 변경 가능<br/>- 순차 접근 가능<br/>- 랜덤 액세스 가능 | - 많은 양의 자료에 불리<br/>- 중간 삽입/삭제<br/>- 검색 느림<br/> |

<br/>

#### < list / forward_list >

- 모든 위치에서 빠른 삽입/삭제가 가능하지만 임의의 요소에 바로 접근할 수는 없다.
- 특정 요소를 읽으려면 순차적으로 탐색해서 찾아야 한다.
- forward_list : 싱글 링크드 리스트

| 장점                                       | 단점                                       |
| ---------------------------------------- | ---------------------------------------- |
| - 중간 삽입/삭제<br/>- 크기 변경 가능<br/>- 적은 양의 자료에 유리<br/>- 순차 접근 가능 | - 많은 양의 자료에 불리<br/>- 랜덤 액세스 불가<br/>- 검색 느림<br/> |

<br/>

<br/>

### 2. 많은 양의 데이터 + 검색 활발

---

<br/>

#### < map >

- 이진 탐색 트리 기반
- 균형 이진 트리 (레드-블랙 트리 : 작은 값이 부모, 왼쪽은 그 다음 큰 값, 오른쪽은 가장 큰 값)
- key - value가 pair로 구성
- key의 중복 허용 : multimap

| 장점                                       | 단점                  |
| ---------------------------------------- | ------------------- |
| - 많은 양의 자료에 유리<br/>- 검색 속도 빠름<br/>- key와 value 따로 저장<br/>- 자동 정렬 | - 적은 양엔 오버헤드로 인해 손해 |

<br/>

#### < set >

- 이진 탐색 트리 기반 (레드-블랙 트리)
- key의 중복 허용 : multiset

| 장점                                       | 단점                  |
| ---------------------------------------- | ------------------- |
| - 많은 양의 자료에 유리<br/>- 검색 속도 빠름<br/>- key가 곧 value, key만 저장<br/>- 자동 정렬 | - 적은 양엔 오버헤드로 인해 손해 |

<br/>

### 3. 기타

---

<br/>

#### < Deque >

- double-ended queue는 vector와 비슷하지만 양쪽 끝에서 효율적으로 원소를 추가/제거할 수 있다.
- 저장 원소가 많고 메모리 할당량이 큰 경우 vector에 비해 확장 비용이 절감된다.
- 컨테이너 처음부터 끝까지 연속 메모리 공간이 아니므로, vector에서 가능했던 원소들 간 포인터 연산이 불가능하다.

<br/>



> 중간 삽입/삭제가 없고 랜덤 접근이 많은 경우 : **vector**
>
> 중간 삽입/삭제가 있고 랜덤 접근이 없는 경우 : **list**
>
> ( 데이터 개수가 적은 경우 vector 사용하는 편이 성능이 더 좋다 )
>
> 컨테이너가 유지되는 동안 계속 순서가 유지되어야 하는 경우 : **set**
>
> 실행 중에 데이터 구조의 크기가 광범위하게 변하는 경우 : **list, set**
>
> 어떤 값이 컨테이너에 속해 있는지를 자주 검사하는 경우 : **set, map**
>
> 가장 큰 값을 찾아서 제거하는 연산이 자주 일어나는 경우 : **priority_queue**
>
> 두 개 이상의 수열을 하나로 합치는 일이 자주 일어나는 경우 : **set, list**

